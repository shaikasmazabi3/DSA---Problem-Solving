Whenever I take a React interview, I start with one deceptively simple question:

ğŸ‘‰ â€œWalk me through what actually happens when you call setState (useState) in React.â€

Surprisingly, most developers struggle here â€” not because itâ€™s hard, but because it requires conceptual clarity, not memorization.

Hereâ€™s the real lifecycle of setState (useState) every React developer should understand ğŸ‘‡

ğŸ”„ How setState (useState) Really Works in React

1ï¸âƒ£ Initial Render

â€¢ useState(initialValue) runs
â€¢ React stores the state internally
â€¢ Component renders using this initial value

2ï¸âƒ£ State Update Is Triggered

â€¢ setState(newValue) is called
â€¢ Triggered by events, API responses, timers, or effects

3ï¸âƒ£ Update Is Scheduled (Not Immediate)

â€¢ State does not update synchronously
â€¢ React queues the update
â€¢ Multiple updates may be batched for performance

4ï¸âƒ£ New State Is Calculated

â€¢ Passing a value â†’ replaces previous state
â€¢ Passing a function â†’ receives previous state
â€¢ Functional updates prevent stale state bugs

5ï¸âƒ£ Re-render Phase

â€¢ Component function executes again
â€¢ useState now returns updated state
â€¢ JSX is recalculated

6ï¸âƒ£ Reconciliation

â€¢ React compares old vs new Virtual DOM
â€¢ Determines the minimum UI changes

7ï¸âƒ£ Commit Phase

â€¢ Only required changes hit the real DOM
â€¢ UI updates become visible

8ï¸âƒ£ Effects Run

â€¢ useEffect hooks execute after DOM updates
â€¢ Effects depending on updated state are triggered

9ï¸âƒ£ Component Settles

â€¢ Component waits for the next state or prop change
â€¢ Cycle repeats on the next update

ğŸ§  Why interviewers love this question

Because it tests whether you understand: â€¢ Asynchronous updates
â€¢ Batching
â€¢ Rendering vs committing
â€¢ Virtual DOM & reconciliation
â€¢ Effect timing

This single explanation separates React users from React engineers.



https://blog.isquaredsoftware.com/2020/05/blogged-answers-a-mostly-complete-guide-to-react-rendering-behavior/